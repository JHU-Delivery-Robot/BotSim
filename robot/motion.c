/*
 * JHU Deliverbot Navigation Group 
 * Navigation simulation system 
 * Motion models --- function implementation file 
 *
 * @avnoks (GitHub)  7 Jan 2021 (create date)
 *
 */

/* A NOTICE (5 Jan 2020): We're at an early stage.  Feel free to change 
 * things like function names and types to things that make more sense.
 */

/* For simulating robot */
#include "motion.h" 

/* For noise generation */
#include <stdlib.h>
#include <math.h> 
#define PI 3.141592654 

/* 
 * Update robot's position with noise using odometry motion model
 * Arguments: 
 *   robot 
 *   lin_velo
 *   ang_velo  
 * Returns nothing.
 */
void update_position(Robot robot, double lin_velo, double ang_velo) 
{
    /* Updating new position without noise */
    double theta_temp = robot.rz + ang_velo * DELTA_T;
    double x_temp = robot.x + cos(theta_temp) * lin_velo;
    double y_temp = robot.y + sin(theta_temp) * lin_velo;

    /* Generating noise */
    double theta_alpha = gaussrand() * SIGMA_ALPHA;   
    double theta_beta = gaussrand() * SIGMA_BETA;
    double transl = gaussrand() * SIGMA_DELTA;

    /* Implementing noise into the new position */
    theta_temp = theta_temp + theta_alpha;
    x_temp = x_temp + cos(theta_temp) * transl;
    y_temp = y_temp + sin(theta_temp) * transl;
    theta_temp = theta_temp + theta_beta;

    /* Updating robot */
    robot.rz = theta_temp;
    robot.x = x_temp;
    robot.y = y_temp;

}


/* 
 * Generates gaussian noise with mean 0 and standard deviation 1, the
 * method is by Abramowitz and Stegun.
 * Returns random number generated by gaussian distribution.
 */
double gaussrand()
{
	static double U, V;
	static int phase = 0;
	double Z;

	if(phase == 0) {
		U = (rand() + 1.) / (RAND_MAX + 2.);
		V = rand() / (RAND_MAX + 1.);
		Z = sqrt(-2 * log(U)) * sin(2 * PI * V);
	} else
		Z = sqrt(-2 * log(U)) * cos(2 * PI * V);

	phase = 1 - phase;

	return Z;
}